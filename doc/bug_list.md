
1. logger的全局初始化问题
2. macro 的函数调用栈打印问题
3. scheduler中 如果idle以协程的方式运行，而wake和idle用条件变量实现，会发现条件变量会无法被唤醒
4. 日志的无序递归打印
5. 当连接的socket数目大于进程的资源限制后，就会一直触发`Too many file`错误，因为此时accept queue 队列已经满了，accept处于可读状态，且尽管我们的事件是采用ET模式，但是我们在触发后就将事件删除掉，然后再次调用accept才再次加回来，所以就依然会触发accept的可读事件，导致accept被疯狂调用，CPU占用率100%
- 解决： 
    1).本身accept是没有问题，因为其一直都是处于可操作状态，而导致上面问题的原因，注意是没有对出错的情况进行处理
    2).利用条件变量来同步，即但出现`Too many file`错误时，就wait，阻塞，而如果有socket close 就唤醒，但是效率太低
    3). 利用一个简单的错误error_eventfd来控制同步，即如果eventfd不可读就yield出去，直到有socket close关闭后就write(eventfd)，使其可读唤醒accept协程
3).综上 这个问题，不管是ET还是LT都没法从accept函数实现上去改进。对于ET,如果每次触发仅仅触发一次，那么会漏掉很多的accept,而如果要持续accept直到其不可读，由于进程的资源限制没法取出，导致其也一直循环
        而对于LT也是一样的道理
  
6. 在测压时出现了，一个问题，就是如果连接数超过资源限制数时，那么由于有一部分连接仅仅放置在accept但没有被取出来，注意点在客户端是无法被感知的，需要增强