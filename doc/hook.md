## 原理

Hook 技术是一种常用的软件技术，可以通过修改或替换系统函数来控制和改变程序的行为。它通常包括两个阶段：

1. Hook 操作：在程序运行时通过修改或替换系统函数的地址来实现对程序行为的监控、干预或改变。

2. 原函数调用：在完成 Hook 操作后，继续调用原始的系统函数，以保证程序正常的运作。

具体来说，Hook 技术的原理是通过操作函数指针，将函数指针指向用户自定义的函数，从而达到监控或篡改目标函数行为的目的。实现 Hook 的方法有很多种，其中比较常见的方式包括：

- API Hook：通过修改函数入口点（entry point）来实现对 API 函数的 Hook。
- Inline Hook：直接修改目标函数的二进制代码，替换原来的机器码来实现 Hook。
- Detour Hook：使用一个跳转函数（trampoline function）来代替原函数，并在跳转函数中实现对原函数的 Hook。

在应用 Hook 技术时需要注意兼容性、稳定性和安全性等问题，同时还需要关注操作系统的权限和安全策略，避免出现意外的错误和风险。

Hook 技术的底层原理涉及到操作系统、编程语言以及计算机体系结构等方面的知识。

在操作系统中，每个可执行文件都包含一个导入表（import table），其中记录了该程序所依赖的 DLL 文件和函数的入口点。当程序调用某个函数时，操作系统会根据导入表查找并加载相应的 DLL 文件，并获取函数的地址来执行。

在使用 Hook 技术时，可以通过修改导入表或重定向表（import address table），将目标函数的地址指向用户自定义的 Hook 函数，从而实现对目标函数的监控、干预或改变。

具体实现方式有多种，其中比较常见的方式是使用 Inline Hook 或 Detour Hook 技术，通过修改目标函数的二进制代码或使用跳转函数来代替原函数，并在新函数中实现 Hook 的逻辑。这样，在程序调用目标函数时，实际上会调用 Hook 函数，从而实现 Hook 的效果。

需要注意的是，Hook 技术的实现可能会影响程序的正常运行和稳定性，因此在使用 Hook 技术时需要谨慎考虑并进行充分测试和评估。同时，还需要关注操作系统和编译器的安全策略，避免出现意外的错误和风险

## 实现方式

在 Linux 下，Hook 技术的实现方式与 Windows 略有不同，主要包括以下几种形式：

1. LD_PRELOAD：通过设置环境变量 LD_PRELOAD 来加载一个动态库，并覆盖系统函数的入口点，从而实现对目标函数的 Hook。这种方式适用于被 Hook 的函数是共享库中导出函数的情况。

2. ptrace：通过 ptrace 系统调用来追踪进程的运行状态，可以读取和修改进程的内存数据和寄存器值，从而实现对函数调用的监控和修改。这种方式适用于 Hook 需要修改进程内存的情况。

3. kprobes：通过内核钩子（kprobe）技术，在内核中添加一个新的函数入口点，从而实现对系统调用和函数调用的监控和干预。这种方式适用于需要对系统调用进行 Hook 或者需要 Hook 内核代码的情况。

4. ftrace：通过内核跟踪（ftrace）技术，在内核中添加一个函数跟踪点，可以对函数调用的进入和退出进行记录和分析。这种方式适用于 Hook 需要对函数调用进行跟踪和分析的情况。

## dlsym的实现

dlsym 是一个 Linux 系统下的动态链接库操作函数，可以用于获取共享库中指定名称的符号（symbol）地址。dlsym 函数通常用于在运行时动态加载共享库，并获取其中某个函数或变量的地址。

具体来说，dlsym 函数接受两个参数：dlopen 打开的共享库句柄和需要查找的符号名称。它会在指定的共享库中查找符号名称，并返回其对应的地址。如果未找到指定的符号，则返回 NULL。

dlsym 函数的实现依赖于 Linux 系统的动态链接器 ld.so，通过解析 ELF 格式的共享库文件，将其映射到进程空间中，并创建符号表等数据结构。在执行 dlsym 函数时，ld.so 会搜索并返回相应的符号地址。

在 Linux 下，可以利用 dlsym 函数实现 Hook 技术，具体步骤如下：

1. 使用 dlopen 函数动态加载目标共享库，并获取其句柄，例如：

```
void* handle = dlopen("libtest.so", RTLD_LAZY);
```

2. 使用 dlsym 函数获取目标函数的地址，例如：

```
void (*origin_func)(int) = (void (*)(int))dlsym(handle, "func");
```

其中，函数指针 origin_func 指向目标函数的地址，可以继续调用该函数。

3. 在获取目标函数地址后，可以通过修改目标函数地址来实现对其 Hook。例如，可以将该地址指向用户自定义的 Hook 函数，从而实现对目标函数的监控、干预或改变。

4. 如果需要调用原始的目标函数，则可以通过调用 origin_func 函数指针来实现，例如：

```
origin_func(123);
```

在使用 dlsym 实现 Hook 技术时需要注意以下几点：

- 需要对目标共享库和符号名称进行正确解析和查找，以避免出现意外的错误；
- 修改目标函数地址需要谨慎考虑，避免影响程序的正常运行；
- 可能会存在符号重定向等问题，需要进行相应的处理和验证；
- 在释放共享库句柄时需要注意内存管理和资源释放，以确保程序的正常运行和稳定性。

## dlsym的RTLD_NEXT原理

RTLD_NEXT 的原理与动态链接库（shared library）加载和符号解析相关。

在 Linux 下，共享库是一种可执行的二进制文件，可以在运行时被加载到内存中并与其他程序共享。共享库包含了多个符号（symbol），其中包括函数、变量等信息，并通过符号表来进行索引和访问。

当程序调用共享库中的函数时，需要先通过动态链接库加载器（dynamic linker loader，简称 ld.so）来将共享库映射到进程的地址空间中，并将符号表中的符号地址与正在运行的进程进行绑定。

在这个过程中，ld.so 会按照一定的顺序查找符号表中的符号，并创建一个函数调用链（function call chain），从而实现了对目标函数的调用。如果目标符号没有被找到，则会发生符号未定义错误（symbol undefined error）。

使用 RTLD_NEXT 参数可以实现对同名符号的查找，并获取下一个共享库中的同名符号地址。具体来说，在 dlsym 函数的实现中，当将参数设置为 RTLD_NEXT 时，动态链接库加载器会跳过当前共享库的符号表，直接搜索下一个共享库的符号表，并返回第一个匹配的同名符号地址。

需要注意的是，使用 RTLD_NEXT 可能会存在符号冲突或者符号重定向等问题，因此在使用时需要谨慎考虑并进行充分测试和评估，以避免出现意外的错误和风险。

### 查找的不足

是的，RTLD_NEXT 可能会查找到其他共享库的同名符号地址。具体来说，当使用 RTLD_NEXT 参数调用 dlsym 函数时，动态链接库加载器会从当前共享库之后加载的所有共享库中查找下一个同名符号地址，并返回第一个匹配的地址。

这意味着，如果存在多个共享库中都有同名符号，则 RTLD_NEXT 参数可能会返回其中一个共享库中的符号地址，而不一定是调用者所希望的目标符号地址。因此，在使用 RTLD_NEXT 参数时需要注意符号冲突或者符号重定向等问题，以避免出现意外的错误和风险。

为了避免这种情况，可以使用其他方法来获取目标函数的地址，例如使用特定的共享库句柄（handle）或者使用符号绑定（symbol binding）等技术。同时还需要注意程序内存管理和资源释放问题，以确保程序的正常运行和稳定性。

## 本地符号表和共享库的符号表有什么区别

地符号表和共享库的符号表是两个不同的概念，分别用于描述程序的本地符号和共享库中的符号。

本地符号表是一个程序二进制文件中的符号表，用于存储程序中定义的函数、变量等符号信息。在程序编译时，编译器会将所有函数、变量等符号及其地址存储在本地符号表中，并在程序运行时使用该符号表来进行符号解析和调用。本地符号表通常保存在可执行文件或者静态库中。

共享库的符号表则是共享库自身的符号表，也称为动态符号表（dynamic symbol table）。共享库中的符号表用于描述共享库中定义的函数、变量等符号信息。当动态链接库加载器将共享库映射到进程的地址空间中时，会将共享库的符号表与进程的符号表进行合并，并创建一个全局符号表（global symbol table）供程序调用。程序可以通过 dlsym 函数来访问共享库中的符号。

需要注意的是，共享库的符号表与本地符号表之间可能存在冲突或者重叠等问题，特别是对于同名符号的处理。因此，在使用符号表进行符号解析和调用时需要进行充分的异常处理和错误检查，以确保程序的正常运行和稳定性。

## 那优先调用哪个符号？

当有多个同名符号时，动态链接库加载器会按照一定的顺序来解析符号并决定要调用哪个符号。

在 Linux 下，通常有两种符号解析方式：lazy binding 和 immediate binding。其中，lazy binding 是默认的符号绑定方式，也称为懒绑定（lazy binding）、延迟绑定或者运行时绑定（runtime binding）。在 lazy binding 模式下，动态链接库加载器会尽可能地将符号解析推迟到函数第一次被调用时，以减少符号表的搜索和解析时间。

具体来说，在 lazy binding 模式下，动态链接库加载器会按照以下顺序来查找同名符号：

1. 本地符号表中的符号
2. 最后一个 RTLD_NEXT (NULL) 之后已经被加载的共享库中的符号
3. 所有之前被加载的共享库中的符号

因此，如果存在多个同名符号，则优先调用最后一个 RTLD_NEXT（NULL）之后已经被加载的共享库中的符号，其次是之前被加载的共享库中的符号，最后才是本地符号表中的符号。

需要注意的是，如果程序使用了符号版本控制等技术来管理符号的作用域和版本，则符号的解析顺序可能会发生变化。同时，还需要关注符号表的大小和加载顺序等问题，以避免出现符号解析失败或者符号冲突等情况。

## 本地程序有和共享库同名的函数，会改变共享库内部的函数调用吗

本地程序中定义的和共享库同名的函数不会改变共享库内部的函数调用。

在动态链接过程中，当共享库中的一个函数被调用时，动态链接器会按照一定的顺序搜索所有已经加载的共享库，并返回第一个匹配的符号地址。如果同时存在本地符号表和共享库的符号表中都有同名符号，则可能会出现符号冲突或者重叠的问题，导致程序的行为不可预测。但无论如何，这些同名符号的优先级只会影响到外部程序对共享库的函数调用，而不会影响共享库内部的函数调用。

具体来说，对于共享库内部的函数调用，编译器在编译时就已将符号解析为共享库中的对应函数地址，并将其嵌入到目标文件中。因此，即使本地程序中定义了和共享库同名的函数，也不会影响共享库内部对该函数的调用。

需要注意的是，在编写程序时需要避免同名符号的存在，并进行充分的错误检查和异常处理，以确保程序的正常运行和稳定性。

但是我们可以通过改变导入共享库的符号来改变函数行为

## dlsym函数具体实现与原理

dlsym 函数是动态链接库中的一个重要函数，用于根据符号名称查找共享库中相应的符号地址。

dlsym 函数的实现原理如下：

1. 首先，它会获取当前进程中已经加载的所有共享库的列表，并遍历这些共享库，从每个共享库的符号表中查找指定的符号名称。

2. 如果在某个共享库的符号表中找到了指定的符号名称，那么 dlsym 函数将返回该符号的地址。如果在任何一个共享库中都没有找到该符号，那么 dlsym 函数将返回 NULL，表示未能成功解析符号。

3. 在对共享库进行符号查找之前，通常需要通过 dlopen 函数来加载共享库并获取其句柄。此外，还可以使用 RTLD_NEXT 参数来查找同名符号在共享库链中的下一个位置，以实现符号覆盖和 Hook 等功能。

## 在获取目标函数地址后，可以通过修改目标函数地址来实现对其 Hook

是的，可以通过修改目标函数地址来实现对其 Hook。

在动态链接过程中，程序会使用 dlsym 函数等来获取共享库中某个函数的地址，然后将该地址嵌入到目标代码中。如果我们想要 Hook 某个函数，通常有以下两种方式：

1. 直接修改符号表中的函数地址：由于共享库中的符号表保存了所有导出的符号信息，包括函数、变量等，我们可以直接修改符号表中目标函数的地址，使其指向 Hook 函数的地址。这样，在对目标函数进行调用时，实际上是调用 Hook 函数的代码段，从而实现了对目标函数的 Hook。

2. 使用静态替换技术：除了直接修改符号表外，还可以使用静态替换技术，将共享库中的原始函数实现复制到另一个内存区域，并在该内存区域中执行 Hook 函数的代码。这样，在对共享库中原始函数地址进行调用时，实际上是调用 Hook 函数所在内存区域的代码段。这种方式也被称为“二次编译”。

除了直接修改符号表和使用静态替换技术，还有一些其他的 Hook 技术可以用于动态链接库的函数调用。下面介绍两种常见的 Hook 技术：

1. LD_PRELOAD 环境变量：在 Linux 系统中，我们可以使用 LD_PRELOAD 环境变量来加载一个共享库，并覆盖某个共享库中的函数实现。具体步骤如下：

- 编写一个共享库，其中包含覆盖目标函数的 Hook 函数实现；
- 将该共享库编译成动态链接库文件；
- 在程序运行前，使用 LD_PRELOAD 环境变量指定要加载的共享库路径即可。

2. 动态修改 GOT 表：GOT 表（全局偏移量表）是一种用于保存全局数据和函数地址的数据结构，它存在于每个共享库的数据段中。在 ELF 格式中，GOT 表通常包含 PLT（过程链接表）和 GOT（全局偏移量表）两个部分，其中 PLT 用于进行函数调用，GOT 用于保存函数地址。通过动态修改 GOT 表中某个函数的地址，可以实现对该函数的 Hook。

-----
`ref :https://www.jianshu.com/p/f7ff5afc1786`

1.1. 利用静态链接
把自己实现的系统调用的源文件编译到可执行文件中。这样在编译时就把符号重定位，该符号也不会出现在动态链接的重定位表中，也就不会使用共享库libc.so.6的实现。

1.2. 利用共享对象全局符号介入（Global Symbol Interpose）的机制
当一个新的共享对象被装载进来的时候，它的符号表会被合并到全局符号表中。当一个符号需要被加入全局符号表时，如果相同的符号已经存在，则后加入的符号被忽略。这就是全局符号介入的机制。

也就是说，如果多个共享对象有相同的全局符号，那么程序最终会使用先加载进来的符号。所以，我们可以把自己实现的系统调用源文件编译成共享对象，然后确保它先于C标准库加载进来就可以。

那么，共享对象加载的顺序如何指定？

我们使用gcc 时，写在前面的共享对象会先于写在后面的被加载（例如，gcc -ldl -lpthread中，dl先于pthread加载），而gcc背后实际执行的ld命令会把-lc添加到我们指定的共享对象的后面。因此，我们只需要把自己的共享对象链接上就可以了。

或者使用LD_PRELOAD环境变量。在程序执行前，LD_PRELOAD环境变量指定的共享对象会先于任何其他的共享对象被加载进来。使用这种方式，就不必在编译时用-l指定链接我们的共享对象了。
